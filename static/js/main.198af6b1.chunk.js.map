{"version":3,"sources":["utils/collision.js","utils/compact.js","utils/index.js","rdx/gridLayout/const.js","rdx/gridLayout/actions.js","rdx/gridLayout/selectors.js","components/Card/Card.js","components/DragIcon/DragIcon.js","components/Dropdown/Dropdown.js","components/TextField/TextField.js","components/TextArea/TextArea.js","components/Checkbox/Checkbox.js","containers/DrawerLayout/DrawerLayout.js","mock/index.js","containers/Content/Content.js","containers/Group/Group.js","containers/DragPreview/DragPreview.js","rdx/gridLayout/reducer.js","rdx/store/reducer.js","rdx/gridLayout/epic.js","rdx/store/epic.js","rdx/store/index.js","containers/Provider/Provider.js","App.js","serviceWorker.js","index.js"],"names":["collision","a","b","gridx","gridy","width","height","getFirstCollison","layout","item","i","length","layoutCheck","_layoutCheck","layoutItem","cardID","fristItemID","compactType","keyArr","movedItem","axis","newlayout","map","index","id","push","offsetXY","widthOrHeight","newItem","c","sortLayout","concat","sort","compactItem","finishedLayout","FirstCollison","compactLayout","movingItem","sorted","compareList","needCompact","Array","finished","getSpaceArea","cols","compactLayoutHorizontal","movingCardID","moveCard","arr","Math","min","layoutBottom","randPos","floor","random","setPropertyValueForCards","BehaviorSubject","groups","property","value","forEach","g","cards","bottomY","max","len","calGridXY","x","y","cardWidth","margin","containerWidth","col","rowHeight","gridX","gridY","w","checkInContainer","RENDER_GRID","BEGIN_DRAG","END_DRAG","renderGrid","payload","type","GR","beginDrag","endDrag","getGroups","state","gridLayout","getLayout","getDefaultLayout","defaultLayout","getShadowCard","shadowCard","getNextCardID","ids","flatMap","cardsCount","getNextGroupID","getDraggableTypes","draggableTypes","Card","groupID","props","dispatch","useDispatch","useSelector","calWidth","draggables","find","getCardByID","isShadow","contentRef","useRef","useDrag","begin","contentBoundingRect","findDOMNode","current","getBoundingClientRect","console","log","contentDomWidth","contentDomHeight","pixelWidth","pixelHeight","end","monitor","didDrop","collect","isDragging","drag","preview","round","calGridItemPosition","h","wPx","hPx","calWHtoPx","useEffect","getEmptyImage","captureDraggingState","className","ref","style","display","justifyContent","alignItems","transform","Draggable","component","opacity","DragIcon","children","nextCardID","wrapRef","pxWidth","pxHeight","pxToWH","useStyles","makeStyles","theme","formControl","spacing","selectEmpty","marginTop","Dropdown","classes","React","useState","age","setAge","FormControl","Select","onChange","event","target","displayEmpty","variant","MenuItem","disabled","FormHelperText","container","flexWrap","textField","marginLeft","marginRight","TextFields","TextField","required","label","defaultValue","dense","menu","padding","flex","placeholder","helperText","fullWidth","multiline","rowsMax","rows","InputLabelProps","shrink","Checkboxes","checked","setChecked","Checkbox","inputProps","root","appBar","drawer","flexShrink","drawerPaper","toolbar","mixins","content","flexGrow","backgroundColor","palette","background","default","PermanentDrawerLeft","CssBaseline","AppBar","position","Toolbar","Typography","noWrap","Drawer","paper","anchor","Divider","List","name","key","ListItem","button","ListItemIcon","ListItemText","primary","Content","window","addEventListener","handleLoad","removeEventListener","render","card","isInvalid","Group","undefined","groupWrapRef","nextGroupID","group","getCards","useDrop","accept","hover","getClientOffset","groupBoudingRect","groupItemX","left","groupItemY","top","drop","mon","isOver","getItem","containerDom","document","querySelector","clientWidth","containerMaxHeight","resultRow","getContainerMaxHeight","containerHeight","layerStyles","pointerEvents","zIndex","DragPreview","useDragLayer","getItemType","initialDomOffset","getInitialClientOffset","currentDomOffset","getSourceClientOffset","currentPointerOffset","getDifferenceFromInitialOffset","offset","dragRef","setX","setY","initX","setInitX","initY","setInitY","dragBoundingRect","dragDomWidth","dragDomHeight","Preview","renderItem","groupIndex","findIndex","cardIndex","cloneDeep","currentGroupIndx","searchResult","remove","compactedLayout","targetGroupIndex","combinedInitStates","containerPadding","fetchCurrencies","action$","state$","pipe","ofType","debounceTime","mergeMap","newLayout","calColWidth","newGroups","of","combineEpics","Object","values","externalInitState","epicMiddleware","createEpicMiddleware","enhancer","compose","applyMiddleware","devToolsEnhancer","trace","traeLimit","initState","merge","store","createStore","combineReducers","run","rootEpic","Provider","initialState","configStore","DndProvider","backend","Backend","App","mockData","TextArea","Boolean","location","hostname","match","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.198af6b1.chunk.js","sourcesContent":["/**\n * Impact checking\n * @param {Object} a\n * @param {Object} b\n * @returns {Boolean} Whether to collide\n */\nexport const collision = (a, b) => {\n  if (\n    a.gridx === b.gridx &&\n    a.gridy === b.gridy &&\n    a.width === b.width &&\n    a.height === b.height\n  ) {\n    return true;\n  }\n  if (a.gridx + a.width <= b.gridx) return false; //a is to the left of b\n  if (a.gridx >= b.gridx + b.width) return false; //a is to the right of b\n  if (a.gridy + a.height <= b.gridy) return false; //a is above b\n  if (a.gridy >= b.gridy + b.height) return false; //a is below b\n  return true;\n};\n/**\n * Get the first object in the layout that the item collided with\n * @param {Array} layout\n * @param {Object} item\n * @returns {Object||null} Collided item or null\n */\nexport const getFirstCollison = (layout, item) => {\n  for (let i = 0, length = layout.length; i < length; i++) {\n    if (collision(layout[i], item)) {\n      return layout[i];\n    }\n  }\n  return null;\n};\n/**\n * Layout detection, recursive detection of whether the moved item and other items collide, if there is a Y coordinate down/X coordinate shift right\n * @param {Array} layout\n * @param {Object} layoutItem\n * @param {String} cardID\n * @param {String} fristItemID\n * @param {String} compactType ('vertical' | 'horizontal') = 'vertical';\n * @returns {Object||null} Collided item or null\n */\nexport const layoutCheck = (function() {\n  const _layoutCheck = function(\n    layout,\n    layoutItem,\n    cardID,\n    fristItemID,\n    compactType = \"vertical\"\n  ) {\n    let keyArr = [];\n    let movedItem = [];\n    let axis = \"gridx\";\n    if (compactType === \"vertical\") {\n      axis = \"gridy\";\n    }\n    // console.log(compactType, \"compactType\");\n    // console.log(movedItem, \"movedItem\");\n    let newlayout = layout.map((item, index) => {\n      if (item.id !== cardID) {\n        if (collision(item, layoutItem)) {\n          // console.log(\"collision detection\");\n          //Collision detection, whether there is a block collision with the current card\n          keyArr.push(item.id);\n          let offsetXY = item[axis] + 1;\n          // The mobile module is located in the loop detection block\n          let widthOrHeight = 0;\n          if (axis === \"gridx\") {\n            widthOrHeight = item.width;\n          } else {\n            widthOrHeight = item.height;\n          }\n          //Determine the coordinates of the current card and the width of the target card/Whether there is overlap in height to prevent overlap\n          if (\n            layoutItem[axis] > item[axis] &&\n            layoutItem[axis] < item[axis] + widthOrHeight\n          ) {\n            offsetXY = item[axis];\n          }\n          let newItem = { ...item };\n          newItem[axis] = offsetXY;\n          // console.log(`Item ${JSON.stringify(newItem)}  Offset ${offsetXY}`);\n          movedItem.push(newItem);\n          return newItem;\n        }\n      } else if (fristItemID === cardID) {\n        return { ...item, ...layoutItem };\n      }\n      return item;\n    });\n    //Cycle through all the cards that have been moved, all related cards affected by collision detection, and all abscissas/Ordinate offset\n    for (let c = 0, length = movedItem.length; c < length; c++) {\n      newlayout = _layoutCheck(\n        newlayout,\n        movedItem[c],\n        keyArr[c],\n        fristItemID,\n        compactType\n      );\n    }\n\n    return newlayout;\n  };\n  return _layoutCheck;\n})();\n","import { layoutBottom, getFirstCollison } from \"utils\";\n/**\n * Sort the items in the layout, according to gridx from small to large, gridy from small to large\n * @param {Array} layout Layout array\n * @returns {Array} New sorted layout\n */\nconst sortLayout = layout => {\n  return [].concat(layout).sort((a, b) => {\n    if (a.gridy > b.gridy || (a.gridy === b.gridy && a.gridx > b.gridx)) {\n      return 1;\n    } else if (a.gridy === b.gridy && a.gridx === b.gridx) {\n      return 0;\n    }\n    return -1;\n  });\n};\n/**\n * Compress individual elements so that each element is next to the border or adjacent elements\n * @param {Array} finishedLayout The compressed elements will be put here to compare whether each element in the future needs to be compressed.\n * @param {Object} item\n * @returns {Object} item Returns the item at the new coordinate position\n */\nconst compactItem = (finishedLayout, item) => {\n  const newItem = { ...item };\n  if (finishedLayout.length === 0) {\n    return { ...newItem, gridy: 0 };\n  }\n\n  while (true) {\n    let FirstCollison = getFirstCollison(finishedLayout, newItem);\n    if (FirstCollison) {\n      newItem.gridy = FirstCollison.gridy + FirstCollison.height;\n      return newItem;\n    }\n    newItem.gridy--;\n    if (newItem.gridy < 0) return { ...newItem, gridy: 0 }; //Hit the border, gridy is set to 0\n  }\n};\n/**\n * Vertical compression, so that each element will be next to the border or adjacent elements\n * @param {Array} layout\n * @param {Object} movingItem\n * @returns {Array} layout Latest layout\n */\nexport const compactLayout = function(layout, movingItem) {\n  let sorted = sortLayout(layout);\n  const compareList = [];\n  const needCompact = Array(layout.length);\n\n  for (let i = 0, length = sorted.length; i < length; i++) {\n    let finished = compactItem(compareList, sorted[i]);\n    compareList.push(finished);\n    needCompact[i] = finished;\n  }\n  return needCompact;\n};\n/**\n * Get free card placement area\n * @param {Array} finishedLayout\n * @param {Object} item\n * @param {Int} cols\n * @returns {Object} Card placement\n */\nconst getSpaceArea = (finishedLayout, item, cols) => {\n  const newItem = { ...item };\n  if (finishedLayout.length === 0) {\n    return newItem;\n  }\n\n  let FirstCollison = getFirstCollison(finishedLayout, newItem);\n  if (FirstCollison) {\n    newItem.gridx++;\n    if (newItem.gridx + item.width > cols) {\n      newItem.gridx = 0;\n      newItem.gridy++;\n    }\n    return getSpaceArea(finishedLayout, newItem, cols);\n  } else {\n    return newItem;\n  }\n};\n\n/**\n * horizontal compact Layout Version2.1\n * Horizontal compression version 2.1\n * First sort the cards by x and y,\n * Place a card to detect collision or beyond the boundary starting from 0, 0. If there is a collision, then grix = 0, y + 1, and check for collision again.\n * Where to optimize: If the coordinates of the card in motion should always be within a range, it should not be dragged anywhere\n * @param {Array} layout\n * @param {Int} cols\n * @param {String} movingCardID Moving elements\n * @returns {layout} Latest layout\n */\nexport const compactLayoutHorizontal = function(layout, cols, movingCardID) {\n  let sorted = sortLayout(layout);\n  const compareList = [];\n  const needCompact = Array(layout.length);\n  let arr = [];\n  let moveCard;\n  //Perform coordinate reset, except for moving cards\n  for (let i = 0; i < sorted.length; i++) {\n    if (movingCardID === sorted[i].id) {\n      moveCard = sorted[i];\n      continue;\n    }\n    arr.push(sorted[i]);\n  }\n  //Get the largest y value in the current group and assign it to the mobile card to prevent the group Y value from becoming infinitely large\n  if (moveCard) {\n    moveCard.gridy = Math.min(layoutBottom(arr), moveCard.gridy);\n  }\n  //Reset coordinates of non-moving cards\n  for (let i = 0; i < sorted.length; i++) {\n    if (movingCardID !== sorted[i].id) {\n      sorted[i].gridy = 0;\n      sorted[i].gridx = 0;\n    }\n  }\n  let rowCount = 0;\n  //Reposition, except for moving cards\n  for (let i = 0, length = sorted.length; i < length; i++) {\n    let finished;\n    if (movingCardID === sorted[i].id) {\n      finished = sorted[i];\n    } else {\n      finished = getSpaceArea(compareList, sorted[i], cols);\n    }\n    compareList.push(finished);\n    needCompact[i] = finished;\n  }\n  return needCompact;\n};\n\n/**\n * horizontal compact Layout Version2.0\n * Horizontal compression version 2.0\n * First sort the cards by x and y,\n * Place a card to detect collision or beyond the boundary starting from 0, 0. If there is a collision, then grix = 0, y + 1, and check for collision again.\n * @param {Array} layout\n * @param {Int} cols\n * @returns {layout} Latest layout\n */\n// export const compactLayoutHorizontal = function(layout, cols) {\n// \tlet sorted = sortLayout(layout);\n// \tconst compareList = [];\n// \tconst needCompact = Array(layout.length);\n\n// \tfor (let i = 0; i < sorted.length; i++) {\n// \t\tsorted[i].gridy = 0;\n// \t\tsorted[i].gridx = 0;\n// \t}\n// \tlet rowCount = 0;\n// \tfor (let i = 0, length = sorted.length; i < length; i++) {\n// \t\tlet finished = getSpaceArea(compareList, sorted[i], cols);\n// \t\tcompareList.push(finished);\n// \t\tneedCompact[i] = finished;\n// \t}\n// \treturn needCompact;\n// };\n\n// export const compactLayoutHorizontal = function( layout, cols ){\n//     let sorted = sortLayout(layout);\n//     const compareList = []\n//     const needCompact = Array(layout.length)\n\n//     for(let i=0;i<sorted.length;i++){\n//         sorted[i].gridy = 0;\n//         sorted[i].gridx = 0;\n//     }\n//     let rowCount = 0;\n//     for(let i=0, length=sorted.length; i<length; i++){\n//         //Get the maximum accumulated width of a row of existing cards\n//         const compareListRow = _.filter(compareList,(c)=>{\n//             return c.gridy == rowCount\n//         });\n//         const ll = layoutHorizontalRowLength(compareListRow);\n//         //If the current maximum width plus the current card width is greater than cols, then put in the next line,\n//         //Otherwise set gridx\n//         if(ll+sorted[i].width > cols){\n//             rowCount++;\n//             sorted[i].gridy = rowCount;\n//         }else{\n//             sorted[i].gridy = rowCount;\n//             sorted[i].gridx = ll;\n//         }\n//         compareList.push(sorted[i]);\n//         needCompact[i] = sorted[i];\n//     }\n//     return needCompact;\n// }\n","import { BehaviorSubject } from \"rxjs\";\nimport { forEach } from \"lodash\";\n\nimport * as collision from \"./collision\";\n\nexport * from \"./collision\";\nexport * from \"./compact\";\n\nconst randPos = () => Math.floor(Math.random() * 8);\nconst subject = new BehaviorSubject([randPos(), randPos()]);\n\nexport const EmitSource = () => {\n  return subject;\n};\n\nexport const moveKnight = (toX, toY) => {\n  subject.next([toX, toY]);\n};\n\nexport const canMoveKnight = (toX, toY) => {\n  const [x, y] = subject.getValue();\n  const dx = toX - x;\n  const dy = toY - y;\n\n  return (\n    (Math.abs(dx) === 2 && Math.abs(dy) === 1) ||\n    (Math.abs(dx) === 1 && Math.abs(dy) === 2)\n  );\n};\n\nexport const ItemTypes = {\n  KNIGHT: \"knight\",\n  FIELD: \"field\"\n};\n\n/**\n * Set card attribute values ​​in groups\n * @param {Array} groups\n * @param {String} property\n * @param {*} value\n */\nexport const setPropertyValueForCards = (groups, property, value) => {\n  forEach(groups, (g, index) => {\n    forEach(g.cards, a => {\n      a[property] = value;\n    });\n  });\n};\n\n/**\n * Known number of placed grids, Calculate how big each cell of the container is\n * @param {Number} containerWidth\n * @param {Number} col\n * @param {Number} containerPadding\n * @param {Number} margin\n * @returns {Number} Cell size\n */\nexport const calColWidth = (containerWidth, col, containerPadding, margin) => {\n  if (margin) {\n    return (\n      (containerWidth - containerPadding[0] * 2 - margin[0] * (col + 1)) / col\n    );\n  }\n  return (containerWidth - containerPadding[0] * 2 - 0 * (col + 1)) / col;\n};\n\n/**\n * Know the size of the grid, calculate the number of grids placed in a row of the container\n * @param {Number} defaultCalWidth\n * @param {Number} containerWidth\n * @param {Number} containerPadding\n * @param {Number} margin\n * @returns {Number} Number of cells per row\n */\nexport const calColCount = (\n  defaultCalWidth,\n  containerWidth,\n  containerPadding,\n  margin\n) => {\n  if (margin) {\n    return Math.floor(\n      (containerWidth - containerPadding[0] * 2 - margin[0]) /\n        (defaultCalWidth + margin[0])\n    );\n  }\n};\n\n/**\n * Get the Y coordinate of the bottom cell in the current layout\n * @param {Array} layout\n * @returns {Number} Bottom cell Y coordinate\n */\nexport const layoutBottom = layout => {\n  let max = 0,\n    bottomY;\n  for (let i = 0, len = layout.length; i < len; i++) {\n    bottomY = layout[i].gridy + layout[i].height;\n    if (bottomY > max) max = bottomY;\n  }\n  return max;\n};\n\n/**\n * Calculate horizontal length\n * @param {Array} layout\n * @returns {Number} The maximum length\n */\nexport const layoutHorizontalRowLength = layout => {\n  let max = 0,\n    rowX;\n  for (let i = 0, len = layout.length; i < len; i++) {\n    rowX = layout[i].gridx + layout[i].width;\n    if (rowX > max) max = rowX;\n  }\n  return max;\n};\n/**\n * Calculate the maximum height of the card container\n * @param {Array} cards\n * @param {Number} rowHeight\n * @param {Number} margin\n * @returns {Number} Container height\n */\nexport const getContainerMaxHeight = (cards, rowHeight, margin) => {\n  const resultRow = layoutBottom(cards);\n  return resultRow * rowHeight + (resultRow - 1) * margin[1] + 2 * margin[1];\n};\n\n/**\n * Give a grid position, calculate the specific position of the element in the container, the unit is px\n * @param {Number} gridx\n * @param {Number} gridy\n * @param {Number} margin\n * @param {Number} rowHeight\n * @param {Number} calWidth\n * @returns {Object} An object containing x, y coordinates\n */\nexport const calGridItemPosition = (\n  gridx,\n  gridy,\n  margin,\n  rowHeight,\n  calWidth\n) => {\n  const x = Math.round(gridx * calWidth + margin[0] * (gridx + 1));\n  const y = Math.round(gridy * rowHeight + margin[1] * (gridy + 1));\n  return {\n    x: x,\n    y: y\n  };\n};\n/**\n * Prevent elements from overflowing the container\n * @param {Int} gridX\n * @param {Int} gridY\n * @param {Int} col\n * @param {Int} w Card width\n * @returns {Object} gridX, gridY cell coordinate object\n */\nexport const checkInContainer = (gridX, gridY, col, w) => {\n  if (gridX + w > col - 1) gridX = col - w; //Right border\n  if (gridX < 0) gridX = 0; //Left border\n  if (gridY < 0) gridY = 0; //Upper border\n  return { gridX, gridY };\n};\n/**\n * Calculate the coordinates of the cell where the x and y pixel values ​​are located\n * @param {Number} x\n * @param {Number} y\n * @param {Number} cardWidth\n * @param {Number} margin\n * @param {Number} containerWidth\n * @param {Number} col\n * @param {Number} rowHeight\n * @returns {Object} An object containing the cell coordinates of gridx and gridy\n */\nexport const calGridXY = (\n  x,\n  y,\n  cardWidth,\n  margin,\n  containerWidth,\n  col,\n  rowHeight\n) => {\n  //When coordinates are converted into a grid, round down, no need to calculate margin\n  let gridX = Math.floor((x / containerWidth) * col);\n  let gridY = Math.floor(y / (rowHeight + (margin ? margin[1] : 0)));\n  //Prevent cards from overflowing the container\n  return checkInContainer(gridX, gridY, col, cardWidth);\n};\n\n/**\n * Width and height calculations become px\n * @param {Number} w\n * @param {Number} h\n * @param {Number} margin\n * @param {Number} rowHeight\n * @param {Number} cardWidth\n * @returns {Object} Contains wPx, hPx object\n */\nexport const calWHtoPx = (w, h, margin, rowHeight, calWidth) => {\n  const wPx = Math.round(w * calWidth + (w - 1) * margin[0]);\n  const hPx = Math.round(h * rowHeight + (h - 1) * margin[1]);\n\n  return { wPx, hPx };\n};\n\n/**\n * Pixel width and height become grid width and height\n * @param {Number} pxWidth\n * @param {Number} pxHeight\n * @param {Number} rowHeight\n * @param {Number} cardWidth\n * @returns {Object} Contains w, h object\n */\nexport const pxToWH = (pxWidth, pxHeight, rowHeight, calWidth) => {\n  const width = Math.round(pxWidth / calWidth);\n  const height = Math.round(pxHeight / rowHeight);\n  return { width, height };\n};\n","export const RENDER_GRID = {\n  SUCCESS: \"@gridLayout: RENDER_GRID_SUCCESS\",\n  ERROR: \"@gridLayout: RENDER_GRID_ERROR\",\n  START: \"@gridLayout: RENDER_GRID_START\"\n};\n\nexport const BEGIN_DRAG = \"@gridLayout: BEGIN_DRAG\";\nexport const END_DRAG = \"@gridLayout: END_DRAG\";\nexport const MOVE_CARD_IN_GROUP = \"@gridLayout: MOVE_CARD_IN_GROUP\";\nexport const CARD_DROP_IN_GROUP = \"@gridLayout: CARD_DROP_IN_GROUP\";\nexport const CARD_HOVER_OVER_GROUP = \"@gridLayout: CARD_HOVER_OVER_GROUP\";\nexport const CREATE_NEW_GROUP = \"@gridLayout: CREATE_NEW_GROUP\";\n","import * as GR from \"./const\";\n\nexport const renderGrid = payload => ({\n  type: GR.RENDER_GRID.START,\n  payload\n});\n\nexport const beginDrag = payload => ({\n  type: GR.BEGIN_DRAG,\n  payload\n});\n\nexport const endDrag = payload => ({\n  type: GR.END_DRAG,\n  payload\n});\n\nexport const moveCardInGroup = payload => ({\n  type: GR.MOVE_CARD_IN_GROUP,\n  payload\n});\n\nexport const cardDropInGroup = payload => ({\n  type: GR.CARD_DROP_IN_GROUP,\n  payload\n});\nexport const cardHoverOverGroup = payload => ({\n  type: GR.CARD_HOVER_OVER_GROUP,\n  payload\n});\nexport const createNewGroup = payload => ({\n  type: GR.CREATE_NEW_GROUP,\n  payload\n});\n","export const getGroups = state => state.gridLayout.groups;\nexport const getLayout = state => state.gridLayout.layout;\nexport const getCompactType = state => state.gridLayout.compantType;\nexport const getDefaultLayout = state => state.gridLayout.defaultLayout;\nexport const getShadowCard = state => state.gridLayout.shadowCard;\nexport const getCardByID = (groupID, cardID) => state =>\n  state.gridLayout.groups\n    .find(({ id }) => id === groupID)\n    .cards.find(({ id }) => id === cardID);\nexport const getNextCardID = state => {\n  const groups = state.gridLayout.groups;\n  if (!groups.length) return 0;\n  const ids = groups.flatMap(({ cards }) => cards.map(({ id }) => id));\n  const cardsCount = ids.length;\n  if (!cardsCount) return 0;\n  return ids.sort((a, b) => a - b)[cardsCount - 1] + 1;\n};\n\nexport const getNextGroupID = state => {\n  const groups = state.gridLayout.groups;\n  if (!groups.length) return 0;\n  const ids = groups.map(({ id }) => id);\n  return ids.sort((a, b) => a - b)[groups.length - 1] + 1;\n};\n\nexport const getCards = groupID => state => {\n  const groups = state.gridLayout.groups;\n  if (!groups.length) return [];\n  const group = groups.find(({ id }) => groupID === id);\n  if (!group) return [];\n  return group.cards;\n};\n\nexport const getShadowedCard = state => {\n  const groups = state.gridLayout.groups;\n  if (!groups.length) return undefined;\n  const cards = groups.flatMap(({ cards }) => cards);\n  const cardsCount = cards.length;\n  if (!cardsCount) return undefined;\n  return cards.find(({ isShadow }) => isShadow === true);\n};\n\nexport const getDraggableTypes = state => state.gridLayout.draggableTypes;\n","import React, { memo, Component, useEffect, useRef } from \"react\";\nimport { useDrag } from \"react-dnd\";\nimport { calWHtoPx, calGridItemPosition } from \"utils\";\nimport { isEqual } from \"lodash\";\nimport { DragSource } from \"react-dnd\";\nimport { useDispatch, useSelector } from \"react-redux\";\nimport {\n  beginDrag,\n  endDrag,\n  getDraggableTypes,\n  getCardByID,\n  getLayout\n} from \"rdx/gridLayout\";\nimport { getEmptyImage } from \"react-dnd-html5-backend\";\nimport { findDOMNode } from \"react-dom\";\n\nimport { pxToWH } from \"utils\";\nimport { findByLabelText } from \"@testing-library/react\";\n\nconst Card = ({ cardID, groupID, props }) => {\n  const dispatch = useDispatch();\n  const { margin, rowHeight, calWidth } = useSelector(getLayout);\n  const draggables = useSelector(getDraggableTypes);\n  const {\n    gridx,\n    gridy,\n    width,\n    height,\n    isShadow,\n    type = \"Card\"\n  } = useSelector(getCardByID(groupID, cardID));\n  const contentRef = useRef(null);\n\n  const [{ isDragging }, drag, preview] = useDrag({\n    item: { type },\n    begin: () => {\n      const contentDom = findDOMNode(contentRef.current);\n      const contentBoundingRect = contentDom.getBoundingClientRect();\n      console.log(contentBoundingRect, \"contentBoundingRect\");\n      const contentDomWidth = contentBoundingRect.width;\n      const contentDomHeight = contentBoundingRect.height;\n      dispatch(beginDrag({ groupID, id: cardID }));\n      return {\n        id: cardID,\n        type,\n        pixelWidth: contentDomWidth,\n        pixelHeight: contentDomHeight\n      };\n    },\n    end: (item, monitor) => {\n      if (!monitor.didDrop()) {\n        dispatch(endDrag({ id: cardID }));\n      }\n    },\n    collect: monitor => ({\n      isDragging: !!monitor.isDragging()\n    })\n  });\n\n  const { x, y } = calGridItemPosition(\n    gridx,\n    gridy,\n    margin,\n    rowHeight,\n    calWidth\n  );\n  const { wPx, hPx } = calWHtoPx(width, height, margin, rowHeight, calWidth);\n\n  useEffect(() => {\n    preview(getEmptyImage(), { captureDraggingState: true });\n  }, []);\n\n  return (\n    <>\n      {isShadow ? (\n        <div\n          className=\"card-shadow\"\n          ref={drag}\n          style={{\n            width: wPx,\n            height: hPx,\n            display: \"flex\",\n            justifyContent: \"center\",\n            alignItems: \"center\",\n\n            transform: `translate(${x}px, ${y}px)`\n          }}\n        >\n          <div ref={contentRef} style={{ width: \"100%\" }}>\n            {/* <div style={{ position: \"absolute\", top: \"0\", right: \"0\" }}>XXX</div> */}\n            {(() => {\n              const Draggable = draggables[type] ?.component;\n              if (Draggable) return <Draggable {...props}></Draggable>;\n              return <div></div>;\n            })()}\n          </div>\n        </div>\n      ) : (\n          <div\n            className=\"card\"\n            ref={drag}\n            style={{\n              width: wPx,\n              height: hPx,\n              opacity: 1,\n              display: \"flex\",\n              justifyContent: \"center\",\n              alignItems: \"center\",\n              transform: `translate(${x}px, ${y}px)`\n            }}\n          >\n            <div ref={contentRef} style={{ width: \"100%\" }}>\n              {/* <div style={{ position: \"absolute\", top: \"0\", right: \"0\" }}>XXX</div> */}\n              {(() => {\n                const Draggable = draggables[type] ?.component;\n                if (Draggable) return <Draggable></Draggable>;\n                return <div>{cardID}</div>;\n              })()}\n            </div>\n          </div>\n        )}\n    </>\n  );\n};\n\nexport default Card;\n","import React, { useRef, useEffect } from \"react\";\nimport { useDrag } from \"react-dnd\";\nimport { useSelector, useDispatch } from \"react-redux\";\nimport { findDOMNode } from \"react-dom\";\nimport { getEmptyImage } from \"react-dnd-html5-backend\";\n\nimport {\n  getNextCardID,\n  beginDrag,\n  endDrag,\n  getLayout,\n  getDraggableTypes\n} from \"rdx/gridLayout\";\nimport { pxToWH } from \"utils\";\n\nconst DragIcon = ({\n  children,\n  type,\n  gridx = 0,\n  gridy = 0,\n  width = undefined,\n  height = undefined\n}) => {\n  const nextCardID = useSelector(getNextCardID);\n  const { rowHeight, calWidth } = useSelector(getLayout);\n  const draggableTypes = useSelector(getDraggableTypes);\n  const dispatch = useDispatch();\n  const wrapRef = useRef(null);\n\n  const [, drag, preview] = useDrag({\n    item: { type },\n    begin: monitor => {\n      const pxWidth = draggableTypes[type].width;\n      const pxHeight = draggableTypes[type].height;\n\n      const { width, height } = pxToWH(pxWidth, pxHeight, rowHeight, calWidth);\n      dispatch(\n        beginDrag({\n          shadowCard: {\n            id: nextCardID,\n            gridx,\n            gridy,\n            type,\n            height,\n            width,\n            isShadow: true\n          }\n        })\n      );\n\n      return {\n        id: nextCardID,\n        type,\n        pixelWidth: pxWidth,\n        pixelHeight: pxHeight\n      };\n    },\n    end: (item, monitor) => {\n      if (!monitor.didDrop()) {\n        dispatch(endDrag({ id: nextCardID }));\n      }\n    },\n    collect: monitor => ({\n      isDragging: !!monitor.isDragging()\n    })\n  });\n  useEffect(() => {\n    preview(getEmptyImage(), { captureDraggingState: true });\n  }, []);\n  return (\n    <div ref={wrapRef} className=\"drag-icon-wrap\">\n      <div className=\"drag-icon\" ref={drag}>\n        {children}\n      </div>\n    </div>\n  );\n};\nexport default DragIcon;\n","import React from \"react\";\nimport { makeStyles } from \"@material-ui/core/styles\";\nimport MenuItem from \"@material-ui/core/MenuItem\";\nimport FormHelperText from \"@material-ui/core/FormHelperText\";\nimport FormControl from \"@material-ui/core/FormControl\";\nimport Select from \"@material-ui/core/Select\";\n\nconst useStyles = makeStyles(theme => ({\n  formControl: {\n    margin: theme.spacing(1),\n    width: \"100%\",\n    margin: \"0\",\n    padding: \"5px\"\n  },\n  selectEmpty: {\n    marginTop: theme.spacing(2)\n  }\n}));\n\nexport default function Dropdown(props) {\n  const classes = useStyles();\n  const [age, setAge] = React.useState(\"\");\n  const handleChange = event => {\n    setAge(event.target.value);\n  };\n  return (\n    <FormControl className={classes.formControl}>\n      <Select\n        value={age}\n        onChange={handleChange}\n        displayEmpty\n        variant={props.variant || \"outlined\"}\n        className={classes.selectEmpty}\n      >\n        <MenuItem value=\"\" disabled>\n          Placeholder\n        </MenuItem>\n        <MenuItem value={10}>Ten</MenuItem>\n        <MenuItem value={20}>Twenty</MenuItem>\n        <MenuItem value={30}>Thirty</MenuItem>\n      </Select>\n      <FormHelperText>Placeholder</FormHelperText>\n    </FormControl>\n  );\n}\n","import React from \"react\";\nimport { makeStyles } from \"@material-ui/core/styles\";\nimport TextField from \"@material-ui/core/TextField\";\n\nconst useStyles = makeStyles(theme => ({\n  container: {\n    display: \"flex\",\n    flexWrap: \"wrap\"\n  },\n  textField: {\n    marginLeft: theme.spacing(1),\n    marginRight: theme.spacing(1)\n  }\n}));\n\nexport default function TextFields() {\n  const classes = useStyles();\n\n  return (\n    <TextField\n      required\n      variant=\"outlined\"\n      id=\"standard-required\"\n      label=\"Required\"\n      defaultValue=\"Hello World\"\n      className={classes.textField}\n      margin=\"normal\"\n    />\n  );\n}\n","import React from \"react\";\nimport clsx from \"clsx\";\nimport { makeStyles } from \"@material-ui/core/styles\";\nimport MenuItem from \"@material-ui/core/MenuItem\";\nimport TextField from \"@material-ui/core/TextField\";\n\nconst useStyles = makeStyles(theme => ({\n  container: {\n    display: \"flex\",\n    flexWrap: \"wrap\"\n  },\n  textField: {\n    marginLeft: theme.spacing(1),\n    marginRight: theme.spacing(1),\n    width: 200\n  },\n  dense: {\n    marginTop: 19\n  },\n  menu: {\n    width: 200\n  }\n}));\n\nexport default function TextFields() {\n  const classes = useStyles();\n\n  return (\n    <div style={{ padding: \"8px\", flex: \"1 1 100%\" }}>\n      <TextField\n        id=\"standard-full-width\"\n        label=\"Label\"\n        placeholder=\"Placeholder\"\n        helperText=\"Text editor!\"\n        fullWidth\n        multiline\n        rowsMax=\"4\"\n        rows=\"4\"\n        variant=\"outlined\"\n        margin=\"normal\"\n        InputLabelProps={{\n          shrink: true\n        }}\n      />\n    </div>\n  );\n}\n","import React from \"react\";\nimport Checkbox from \"@material-ui/core/Checkbox\";\n\nexport default function Checkboxes() {\n  const [checked, setChecked] = React.useState(true);\n\n  const handleChange = event => {\n    setChecked(event.target.checked);\n  };\n\n  return (\n    <Checkbox\n      checked={checked}\n      onChange={handleChange}\n      value=\"primary\"\n      inputProps={{ \"aria-label\": \"primary checkbox\" }}\n    />\n  );\n}\n","import React, { useState, useEffect } from \"react\";\nimport { makeStyles } from \"@material-ui/core/styles\";\nimport Drawer from \"@material-ui/core/Drawer\";\nimport CssBaseline from \"@material-ui/core/CssBaseline\";\nimport AppBar from \"@material-ui/core/AppBar\";\nimport Toolbar from \"@material-ui/core/Toolbar\";\nimport List from \"@material-ui/core/List\";\nimport Typography from \"@material-ui/core/Typography\";\nimport Divider from \"@material-ui/core/Divider\";\nimport ListItem from \"@material-ui/core/ListItem\";\nimport ListItemIcon from \"@material-ui/core/ListItemIcon\";\nimport ListItemText from \"@material-ui/core/ListItemText\";\nimport Add from \"@material-ui/icons/Add\";\nimport { map } from \"lodash\";\nimport { useSelector } from \"react-redux\";\n\nimport { Board } from \"containers\";\nimport { EmitSource } from \"utils\";\nimport { interval } from \"rxjs\";\nimport { Content } from \"containers\";\nimport { DragIcon } from \"components\";\nimport { getDraggableTypes } from \"rdx/gridLayout\";\n\nconst drawerWidth = 240;\n\nconst useStyles = makeStyles(theme => ({\n  root: {\n    display: \"flex\"\n  },\n  appBar: {\n    width: `calc(100% - ${drawerWidth}px)`,\n    marginLeft: drawerWidth\n  },\n  drawer: {\n    width: drawerWidth,\n    flexShrink: 0\n  },\n  drawerPaper: {\n    width: drawerWidth\n  },\n  toolbar: theme.mixins.toolbar,\n  content: {\n    flexGrow: 1,\n    backgroundColor: theme.palette.background.default,\n    padding: theme.spacing(3)\n  }\n}));\n\nexport default function PermanentDrawerLeft() {\n  const classes = useStyles();\n  const draggables = useSelector(getDraggableTypes);\n\n  return (\n    <div className={classes.root}>\n      <CssBaseline />\n      <AppBar position=\"fixed\" className={classes.appBar}>\n        <Toolbar>\n          <Typography variant=\"h6\" noWrap>\n            Draggable Form builder\n          </Typography>\n        </Toolbar>\n      </AppBar>\n      <Drawer\n        className={classes.drawer}\n        variant=\"permanent\"\n        classes={{\n          paper: classes.drawerPaper\n        }}\n        anchor=\"left\"\n      >\n        <div className={classes.toolbar} />\n        <Divider />\n        <List>\n          {map(draggables, ({ type, name }) => (\n            <DragIcon type={type} key={type}>\n              <ListItem button key={type}>\n                <ListItemIcon>\n                  <Add />\n                </ListItemIcon>\n                <ListItemText primary={name} />\n              </ListItem>\n            </DragIcon>\n          ))}\n        </List>\n      </Drawer>\n      <main className={classes.content}>\n        <div className={classes.toolbar} />\n        <Content></Content>\n      </main>\n    </div>\n  );\n}\n","export default [\n  {\n    id: 0,\n    type: \"Group\",\n    cards: [\n      {\n        id: 0,\n        gridx: 0,\n        gridy: 0,\n        width: 20,\n        height: 1,\n        type: \"Card\",\n        isShadow: false,\n        props: {}\n      },\n      {\n        id: 1,\n        gridx: 1,\n        gridy: 0,\n        width: 20,\n        height: 2,\n        type: \"Dropdown\",\n        isShadow: false,\n        props: {}\n      },\n      {\n        id: 2,\n        gridx: 2,\n        gridy: 0,\n        width: 10,\n        height: 2,\n        type: \"TextField\",\n        isShadow: false,\n        props: {}\n      },\n      {\n        id: 3,\n        gridx: 4,\n        gridy: 0,\n        width: 10,\n        height: 1,\n        type: \"Card\",\n        isShadow: false,\n        props: {}\n      }\n    ]\n  },\n  {\n    id: 0,\n    type: \"Group\",\n    cards: [\n      {\n        id: 0,\n        gridx: 0,\n        gridy: 0,\n        width: 20,\n        height: 1,\n        type: \"Card\",\n        isShadow: false,\n        props: {}\n      },\n      {\n        id: 1,\n        gridx: 1,\n        gridy: 0,\n        width: 20,\n        height: 2,\n        type: \"Dropdown\",\n        isShadow: false,\n        props: {}\n      },\n      {\n        id: 2,\n        gridx: 2,\n        gridy: 0,\n        width: 10,\n        height: 2,\n        type: \"TextField\",\n        isShadow: false,\n        props: {}\n      },\n      {\n        id: 3,\n        gridx: 4,\n        gridy: 0,\n        width: 10,\n        height: 1,\n        type: \"Card\",\n        isShadow: false,\n        props: {}\n      }\n    ]\n  }\n];\n\n/*\n\nShowcaseLayout.defaultProps = {\n  className: \"layout\",\n  rowHeight: 40,\n  onLayoutChange: function() {},\n  cols: { lg: 20, md: 20, sm: 20, xs: 20, xxs: 20 },\n  initialLayout: generateLayout()\n};\n\nfunction generateLayout() {\n  return [\n    {\n      x: 0,\n      y: 0,\n      w: 20,\n      h: 1,\n      i: \"0\",\n      statis: false\n    },\n    {\n      x: 1,\n      y: 0,\n      w: 20,\n      h: 1,\n      i: \"1\",\n      statis: false\n    },\n    {\n      x: 0,\n      y: 0,\n      w: 10,\n      h: 1,\n      i: \"2\",\n      statis: false\n    },\n    {\n      x: 10,\n      y: 0,\n      w: 10,\n      h: 1,\n      i: \"3\",\n      statis: false\n    }\n  ];\n}\n*/\n","import React, { useState, useEffect, Component } from \"react\";\nimport mockData from \"mock\";\nimport { Group } from \"containers\";\nimport { cloneDeep, forEach, map } from \"lodash\";\nimport { useSelector, useDispatch } from \"react-redux\";\nimport { Card } from \"components\";\nimport { DndProvider, useDrop } from \"react-dnd\";\nimport Backend from \"react-dnd-html5-backend\";\n\nimport { calColCount, calColWidth, compactLayoutHorizontal } from \"utils\";\nimport {\n  getCompactType,\n  getDefaultLayout,\n  getGroups,\n  getLayout,\n  renderGrid\n} from \"rdx/gridLayout\";\n\nconst Content = () => {\n  const dispatch = useDispatch();\n  const groups = useSelector(getGroups);\n  const layout = useSelector(getLayout);\n  const defaultLayout = useSelector(getDefaultLayout);\n\n  useEffect(() => {\n    window.addEventListener(\"resize\", handleLoad);\n    return () => window.removeEventListener(\"resize\", handleLoad);\n  }, []);\n\n  const initGroupItem = groups => {\n    let itemDoms = [];\n    itemDoms = groups.map((g, i) => {\n      return <Group id={g.id} />;\n    });\n    return itemDoms;\n  };\n\n  const handleLoad = () => {\n    dispatch(renderGrid());\n  };\n  return (\n    <div>\n      <Group\n        id={0}\n        render={(cards, groupID) =>\n          map(cards, card => (\n            <Card\n              key={`${groupID}_${card.id}`}\n              cardID={card.id}\n              groupID={groupID}\n              props={{\n                type: \"text\",\n                name: \"clientCode\",\n                placeholder: \"Please insert your account number\",\n                onChange: () => {},\n                value: \"\",\n                isInvalid: true\n              }}\n            />\n          ))\n        }\n      ></Group>\n      <Group\n        render={(cards, groupID) =>\n          map(cards, card => (\n            <Card\n              key={`${groupID}_${card.id}`}\n              cardID={card.id}\n              groupID={groupID}\n            />\n          ))\n        }\n      />\n    </div>\n  );\n};\nexport default Content;\n","import React, {\n  useEffect,\n  useLayoutEffect,\n  useMemo,\n  useRef,\n  Fragment,\n  useState\n} from \"react\";\nimport { DndProvider, useDrop } from \"react-dnd\";\nimport Backend from \"react-dnd-html5-backend\";\n\nimport { map } from \"lodash\";\n\nimport { getContainerMaxHeight } from \"utils\";\nimport {\n  moveCardInGroup,\n  cardDropInGroup,\n  cardHoverOverGroup,\n  getDraggableTypes,\n  renderGrid,\n  getNextGroupID,\n  getCards,\n  getLayout,\n  getDefaultLayout,\n  createNewGroup\n} from \"rdx/gridLayout\";\nimport { Card } from \"components\";\nimport { findDOMNode } from \"react-dom\";\nimport { useDispatch, useSelector } from \"react-redux\";\n\nconst Group = ({ id = undefined, children, render }) => {\n  const dispatch = useDispatch();\n  const groupWrapRef = useRef(null);\n  const draggableTypes = useSelector(getDraggableTypes);\n  const layout = useSelector(getLayout);\n  const defaultLayout = useSelector(getDefaultLayout);\n  const nextGroupID = useSelector(getNextGroupID);\n  const [groupID] = useState(id === undefined ? nextGroupID : id);\n  const cards = useSelector(getCards(groupID));\n\n  useEffect(() => {\n    console.log(nextGroupID, \"nextGroupID\");\n    if (id === undefined) dispatch(createNewGroup({ groupID: nextGroupID }));\n  }, []);\n\n  const [{ isOver, item }, drop] = useDrop({\n    accept: [\"Card\", ...map(draggableTypes, ({ type }) => type)],\n    hover(item, monitor, component) {\n      if (groupWrapRef?.current) {\n        // const hoverItem = props;\n        // console.log(drop());\n        const { x, y } = monitor.getClientOffset();\n\n        const groupDom = findDOMNode(groupWrapRef.current);\n        const groupBoudingRect = groupDom.getBoundingClientRect();\n\n        const groupItemX = groupBoudingRect.left;\n        const groupItemY = groupBoudingRect.top;\n        console.log(\n          x - groupItemX - item.pixelWidth / 2,\n          y - groupItemY,\n          \"x, y\"\n        );\n        console.log(item, \"item\");\n        dispatch(\n          moveCardInGroup({\n            cardID: item.id,\n            groupID,\n            x: x - groupItemX - item.pixelWidth / 2,\n            y: y - groupItemY\n          })\n        );\n      }\n    },\n    drop(item, monitor) {\n      dispatch(cardDropInGroup());\n    },\n    collect: mon => ({\n      isOver: mon.isOver(),\n      item: mon.getItem()\n    })\n  });\n\n  useEffect(() => {\n    if (groupWrapRef?.current) {\n      dispatch(cardHoverOverGroup({ groupID: groupID, isOver }));\n    }\n  }, [dispatch, groupID, isOver]);\n\n  useEffect(() => {\n    const containerDom = document.querySelector(\".card-container\");\n\n    if (layout.containerWidth !== containerDom.clientWidth) {\n      dispatch(renderGrid());\n    }\n  }, []);\n\n  const containerMaxHeight = getContainerMaxHeight(\n    cards,\n    layout.rowHeight,\n    layout.margin\n  );\n\n  return (\n    <div ref={groupWrapRef}>\n      <div className=\"group-item\" ref={drop}>\n        <div\n          className=\"group-item-container\"\n          style={{\n            background: isOver ? \"rgba(79,86,98,.1)\" : \"transparent\"\n          }}\n        >\n          <section\n            className=\"card-container\"\n            style={{\n              height:\n                containerMaxHeight > defaultLayout.containerHeight\n                  ? containerMaxHeight\n                  : defaultLayout.containerHeight\n            }}\n          >\n            {render(cards, groupID)}\n          </section>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default Group;\n","import React, { useEffect, useState, useRef } from \"react\";\nimport { useDragLayer } from \"react-dnd\";\nimport { useSelector } from \"react-redux\";\n\nimport { findDOMNode } from \"react-dom\";\nimport {\n  getShadowedCard,\n  getShadowCard,\n  getDraggableTypes\n} from \"rdx/gridLayout\";\n\nconst layerStyles = {\n  position: \"fixed\",\n  pointerEvents: \"none\",\n  zIndex: 9999,\n  left: 0,\n  top: 0,\n  width: \"100%\",\n  height: \"100%\"\n};\n\nconst DragPreview = props => {\n  const {\n    type,\n    isDragging,\n    currentDomOffset,\n    currentPointerOffset,\n    initialDomOffset,\n    item,\n    offset\n  } = useDragLayer(monitor => ({\n    item: monitor.getItem(),\n    type: monitor.getItemType(),\n    initialDomOffset: monitor.getInitialClientOffset(),\n    currentDomOffset: monitor.getSourceClientOffset(),\n    currentPointerOffset: monitor.getDifferenceFromInitialOffset(),\n    isDragging: monitor.isDragging(),\n    offset: monitor.getDifferenceFromInitialOffset()\n  }));\n  const dragRef = useRef(null);\n  const [x, setX] = useState(0);\n  const [y, setY] = useState(0);\n  const [initX, setInitX] = useState(0);\n  const [initY, setInitY] = useState(0);\n  const shadowCard = useSelector(getShadowCard);\n\n  useEffect(() => {\n    if (initialDomOffset && dragRef?.current && currentPointerOffset) {\n      const dragDom = findDOMNode(dragRef.current);\n      const dragBoundingRect = dragDom.getBoundingClientRect();\n      const dragDomWidth = dragBoundingRect.width;\n      const dragDomHeight = dragBoundingRect.height;\n      setInitX(initialDomOffset.x - dragDomWidth / 2);\n      setInitY(initialDomOffset.y - dragDomHeight / 2);\n    }\n    if (currentPointerOffset) {\n      setX(currentPointerOffset.x);\n      setY(currentPointerOffset.y);\n    }\n  }, [currentDomOffset, initialDomOffset, currentPointerOffset]);\n\n  const draggables = useSelector(getDraggableTypes);\n  function renderItem() {\n    if (\n      (shadowCard &&\n        item &&\n        shadowCard?.id === item?.id &&\n        shadowCard.isOver) ||\n      !draggables[type]?.component\n    ) {\n      // console.log(\"returned\", shadowCard?.id);\n      return <></>;\n    }\n    const Preview = draggables[type].component;\n    return <Preview></Preview>;\n  }\n\n  return (\n    <div className=\"drag-preview\" style={layerStyles}>\n      <div\n        ref={dragRef}\n        style={{\n          position: \"absolute\",\n          top: initY,\n          left: initX,\n          transform: `translate(${x}px, ${y}px)`\n        }}\n      >\n        {renderItem()}\n      </div>\n    </div>\n  );\n};\nexport default DragPreview;\n","import * as GR from \"rdx/gridLayout/const\";\nimport mockData from \"mock\";\nimport { cloneDeep, forEach, remove } from \"lodash\";\n\nimport { getCardByID } from \"rdx/gridLayout\";\nimport {\n  calGridXY,\n  layoutCheck,\n  compactLayout,\n  compactLayoutHorizontal,\n  setPropertyValueForCards\n} from \"utils\";\nimport { getShadowCard, getNextGroupID } from \"./selectors\";\n\nexport const initState = {\n  compactType: \"vertical\",\n  defaultLayout: {\n    containerWidth: 0,\n    containerHeight: 0,\n    calWidth: 0,\n    rowHeight: 0,\n    col: 20,\n    margin: [10, 10],\n    containerPadding: [0, 0]\n  },\n  layout: {\n    containerWidth: 0,\n    containerHeight: 0,\n    calWidth: 0,\n    rowHeight: 40,\n    col: 20,\n    margin: [10, 10],\n    containerPadding: [0, 0]\n  },\n  shadowCard: undefined,\n  draggableTypes: {}\n};\n\nexport default (state = {}, { payload, type }) => {\n  switch (type) {\n    case GR.RENDER_GRID.SUCCESS: {\n      return { ...state, layout: payload.layout, groups: payload.groups };\n    }\n    case GR.BEGIN_DRAG: {\n      if (payload.shadowCard) {\n        return {\n          ...state,\n          shadowCard: payload.shadowCard\n        };\n      } else {\n        const groupIndex = state.groups.findIndex(\n          ({ id }) => id === payload.groupID\n        );\n\n        const cardIndex = state.groups[groupIndex].cards.findIndex(\n          ({ id }) => id === payload.id\n        );\n        let groups = cloneDeep(state.groups);\n        groups[groupIndex].cards[cardIndex] = {\n          ...groups[groupIndex].cards[cardIndex],\n          isShadow: true\n        };\n        const shadowCard = cloneDeep(groups[groupIndex].cards[cardIndex]);\n        return {\n          ...state,\n          shadowCard,\n          groups\n        };\n      }\n    }\n\n    case GR.END_DRAG: {\n      let cardIndex = -1;\n      let groupIndex = -1;\n      state.groups.forEach(({ cards }, currentGroupIndx) => {\n        const searchResult = cards.findIndex(({ id }) => id === payload.id);\n        if (searchResult => 0) {\n          groupIndex = currentGroupIndx;\n          cardIndex = searchResult;\n        }\n      });\n\n      if (cardIndex >= 0) {\n        let groups = cloneDeep(state.groups);\n        groups[groupIndex].cards[cardIndex] = {\n          ...groups[groupIndex].cards[cardIndex],\n          isShadow: false\n        };\n        return { ...state, shadowCard: undefined, groups };\n      } else {\n        // let groups = cloneDeep(state.groups);\n        // forEach(groups, (g, index) => {\n        //   remove(g.cards, a => {\n        //     return a.isShadow === true;\n        //   });\n        // });\n        return { ...state, shadowCard: undefined };\n      }\n    }\n\n    case GR.MOVE_CARD_IN_GROUP: {\n      /**\n       * Drag the card to move on the group\n       * @param {Number} payload.groupID ID of group being hover over\n       * @param {Number} payload.cardID ID of card being dragged\n       * @param {Number} payload.x The x-axis position of the webpage where the current element is located, in px\n       * @param {Number} payload.y The y-axis position of the web page where the current element is located, in px\n       **/\n\n      let groups = cloneDeep(state.groups);\n      let shadowCard = cloneDeep(getShadowCard({ gridLayout: state }));\n      const { margin, containerWidth, col, rowHeight } = state.layout;\n\n      // Calculate the current grid coordinates for shadow card\n      const { gridX, gridY } = calGridXY(\n        payload.x,\n        payload.y,\n        shadowCard.width,\n        margin,\n        containerWidth,\n        col,\n        rowHeight\n      );\n      if (gridX === shadowCard.gridx && gridY === shadowCard.gridy) {\n        return state;\n      }\n      const groupIndex = state.groups.findIndex(\n        ({ id }) => id === payload.groupID\n      );\n\n      // //First determine if the same cards exist in the group\n      // const cardid = shadowCard.id;\n\n      // Delete the shadow card\n      forEach(groups, (g, index) => {\n        remove(g.cards, a => {\n          return a.isShadow === true;\n        });\n      });\n\n      shadowCard = { ...shadowCard, gridx: gridX, gridy: gridY };\n      //Add shadow card\n      groups[groupIndex].cards.push(shadowCard);\n\n      // Get the latest layout in the current group\n      const newlayout = layoutCheck(\n        groups[groupIndex].cards,\n        shadowCard,\n        shadowCard.id,\n        shadowCard.id,\n        state.compactType\n      );\n\n      //Compress the layout within the current group\n      let compactedLayout;\n      if (state.compactType === \"horizontal\") {\n        compactedLayout = compactLayoutHorizontal(\n          newlayout,\n          state.layout.col,\n          shadowCard.id\n        );\n      } else if (state.compactType === \"vertical\") {\n        compactedLayout = compactLayout(newlayout, shadowCard);\n      }\n\n      //Update the group object\n      groups[groupIndex].cards = compactedLayout;\n\n      return {\n        ...state,\n        shadowCard,\n        groups\n      };\n    }\n    case GR.CREATE_NEW_GROUP: {\n      const groups = cloneDeep(state.groups);\n      // const nextGroupID = getNextGroupID({ gridLayout: state });\n      // console.log(nextGroupID)\n      groups.push({ id: payload.groupID, type: \"Group\", cards: [] });\n      return {\n        ...state,\n        groups\n      };\n    }\n    case GR.CARD_DROP_IN_GROUP: {\n      /**\n       * Free card to group\n       **/\n\n      let groups = cloneDeep(state.groups);\n      //Make shadow cards in all groups non-shadow\n      setPropertyValueForCards(groups, \"isShadow\", false);\n      //Resizing the layout horizontally within the target group\n      forEach(groups, (g, targetGroupIndex) => {\n        if (state.compactType === \"horizontal\") {\n          let compactedLayout = compactLayoutHorizontal(\n            groups[targetGroupIndex].cards,\n            state.layout.col\n          );\n          groups[targetGroupIndex].cards = compactedLayout;\n        } else if (state.compactType === \"vertical\") {\n          let compactedLayout = compactLayout(groups[targetGroupIndex].cards);\n          groups[targetGroupIndex].cards = compactedLayout;\n        }\n      });\n      return {\n        ...state,\n        shadowCard: undefined,\n        groups\n      };\n    }\n    case GR.CARD_HOVER_OVER_GROUP: {\n      if (!payload.isOver) {\n        return {\n          ...state,\n          shadowCard: {\n            ...state.shadowCard,\n            isOver: payload.isOver,\n            groupID: undefined\n          }\n        };\n      }\n      return {\n        ...state,\n        shadowCard: {\n          ...state.shadowCard,\n          isOver: payload.isOver,\n          groupID: payload.groupID\n        }\n      };\n    }\n    default: {\n      return state;\n    }\n  }\n};\n","import { combineReducers } from \"redux\";\nimport gridLayout, {\n  initState as gridLayoutState\n} from \"rdx/gridLayout/reducer\";\n\nexport const combinedInitStates = {\n  gridLayout: gridLayoutState\n};\n\nexport default () =>\n  combineReducers({\n    gridLayout\n  });\n","import * as GR from \"rdx/gridLayout/const\";\nimport { ofType } from \"redux-observable\";\nimport { mergeMap, catchError, debounceTime } from \"rxjs/operators\";\nimport { from, of, merge } from \"rxjs\";\nimport { cloneDeep, forEach } from \"lodash\";\nimport { calColCount, calColWidth, compactLayoutHorizontal } from \"utils\";\nimport { getDefaultLayout } from \"rdx/gridLayout\";\nimport { getLayout, getGroups, renderGrid } from \"rdx/gridLayout\";\n\nexport const fetchCurrencies = (action$, state$) =>\n  action$.pipe(\n    ofType(GR.RENDER_GRID.START),\n    debounceTime(500),\n    mergeMap(() => {\n      let clientWidth;\n      const containerDom = document.querySelector(\".card-container\");\n      if (containerDom) {\n        clientWidth = containerDom.clientWidth;\n      } else {\n        return;\n      }\n\n      const layout = getLayout(state$.value);\n      const groups = getGroups(state$.value);\n\n      const { containerPadding, margin } = layout;\n      let newLayout = cloneDeep(layout);\n      /*\n      This is responsive col count:\n\n      const defaultCalWidth = getDefaultLayout(state$.value).calWidth;\n      const windowWidth = window.innerWidth - 60 * 2;\n      const col = calColCount(\n        defaultCalWidth,\n        windowWidth,\n        containerPadding,\n        margin\n      );\n      */\n      const col = newLayout.col;\n      const calWidth = calColWidth(clientWidth, col, containerPadding, margin);\n\n      let newGroups = cloneDeep(groups);\n      forEach(newGroups, g => {\n        let compactedLayout = compactLayoutHorizontal(g.cards, col);\n        g.cards = compactedLayout;\n      });\n      /*\n      This is \n      \n      newLayout.calWidth = newLayout.rowHeight = calWidth;\n      */\n      newLayout.calWidth = calWidth;\n      newLayout.col = col;\n      newLayout.containerWidth = clientWidth;\n\n      return of({\n        type: GR.RENDER_GRID.SUCCESS,\n        payload: { groups: newGroups, layout: newLayout }\n      });\n    })\n  );\n","import { combineEpics } from \"redux-observable\";\n\nimport * as gridLayout from \"rdx/gridLayout/epic\";\n\nexport default combineEpics(...Object.values(gridLayout));\n","import { devToolsEnhancer } from \"redux-devtools-extension/developmentOnly\";\nimport { createStore, applyMiddleware, compose } from \"redux\";\nimport { createEpicMiddleware } from \"redux-observable\";\nimport { merge } from \"lodash\";\n\nimport rootReducer, { combinedInitStates } from \"./reducer\";\nimport rootEpic from \"./epic\";\n\nexport default externalInitState => {\n  const epicMiddleware = createEpicMiddleware();\n\n  const enhancer = compose(\n    applyMiddleware(epicMiddleware),\n    devToolsEnhancer({\n      name: \"Erply Launchpad\",\n      trace: true,\n      traeLimit: 30\n    })\n  );\n  const initState = merge(externalInitState, combinedInitStates);\n  console.log(initState, \"initState\");\n  const store = createStore(rootReducer(), initState, enhancer);\n\n  if (module.hot) {\n    // Enable Webpack hot module replacement for reducers\n    module.hot.accept(\"./reducer\", () => {\n      const nextReducer = require(\"./reducer\").default; // eslint-disable-line global-require\n\n      store.replaceReducer(nextReducer);\n    });\n  }\n  epicMiddleware.run(rootEpic);\n\n  return store;\n};\n","import React from \"react\";\nimport { Provider as ReduxProvider } from \"react-redux\";\nimport { DndProvider } from \"react-dnd\";\nimport Backend from \"react-dnd-html5-backend\";\n\nimport configStore from \"rdx/store\";\nconst Provider = ({ children, draggableTypes, initialState }) => {\n  return (\n    <ReduxProvider\n      store={configStore({\n        gridLayout: {\n          draggableTypes,\n          groups: initialState\n        }\n      })}\n    >\n      <DndProvider backend={Backend}>{children}</DndProvider>\n    </ReduxProvider>\n  );\n};\n\nexport default Provider;\n","import React from \"react\";\nimport \"./App.scss\";\nimport { DrawerLayout, DragPreview } from \"containers\";\nimport { Dropdown, TextField, TextArea, Checkbox } from \"components\";\nimport { Provider } from \"containers\";\nimport mockData from \"mock\";\n\nfunction App() {\n  console.log(Dropdown, \"Dropdown\");\n  console.log(<Dropdown></Dropdown>, \"Dropdown\");\n  return (\n    <Provider\n      initialState={mockData}\n      draggableTypes={{\n        Dropdown: {\n          component: Dropdown,\n          name: \"Dropdown\",\n          type: \"Dropdown\",\n          width: 170,\n          height: 100\n        },\n        TextField: {\n          component: TextField,\n          name: \"Text Field\",\n          type: \"TextField\",\n          width: 200,\n          height: 60\n        },\n        TextArea: {\n          component: TextArea,\n          name: \"Text Area\",\n          type: \"TextArea\",\n          width: 470,\n          height: 175\n        },\n        Checkbox: {\n          component: Checkbox,\n          name: \"Checkbox\",\n          type: \"Checkbox\",\n          width: 42,\n          height: 42\n        }\n      }}\n    >\n      <div className=\"App\">\n        <DragPreview></DragPreview>\n        <DrawerLayout></DrawerLayout>\n      </div>\n    </Provider>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport { render } from \"react-dom\";\n\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\nimport \"./index.css\";\n\nrender(<App></App>, document.getElementById(\"root\"));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}